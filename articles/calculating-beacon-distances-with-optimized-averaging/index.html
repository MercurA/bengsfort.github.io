<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width initial-scale=1">
	
		<title>Calculating iBeacon distances with optimized averaging</title>
	
		<!--// Metadata //-->
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width initial-scale=1">
	
		<!--// Metadata //-->
		<meta name="description" content="Words and thoughts about app development, indie game development, and pixel art.">
		<meta property="og:type" content="website">
		<meta property="og:title" content="Developmental Pixels">
		<meta property="og:url" content="http://aesinv.com/index.html">
		<meta property="og:site_name" content="Developmental Pixels">
		<meta property="og:description" content="Words and thoughts about app development, indie game development, and pixel art.">
		<meta name="twitter:card" content="summary">
		<meta name="twitter:title" content="Developmental Pixels">
		<meta name="twitter:description" content="Words and thoughts about app development, indie game development, and pixel art.">
		<meta name="twitter:creator" content="@bengsfort">
		<meta property="fb:admins" content="100000177595822">
		<meta property="fb:app_id" content="1893256420958255">
		
		
		<!--// Stylesheets //-->
		<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
		<link href="/styles/main.css" rel="stylesheet">
		<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/atom-one-dark.min.css">
	</head>
	<body>
		<header>
			<a class="nav-menu-trigger waves-effect waves-light" data-target=".nav-pane">
				<i class="material-icons close">close</i>
				<i class="material-icons open">menu</i>
			</a>
			<div class="nav-pane">
				<div class="nav-content">
					<div class="author-card">
						<div class="author-card-top">
							<div class="author-avatar-wrapper">
								<img class="author-avatar" src="/assets/avatar.png" alt="Matt Bengston" />
							</div>
						</div>
					
						<div class="author-card-body">
							<h5 class="author-name">Matt Bengston</h5>
							
							<div class="author-job-info">
								<span class="author-position">Software Developer</span>
								<a class="author-employer" target="_blank" href="https://unity3d.com">Unity Technologies</a>
							</div>
					
							<div class="author-social">
								<a class="author-github" target="_blank" href="https://github.com/bengsfort">
									<svg class="icon icon-github-with-circle">
										<use xlink:href="#icon-github-with-circle" />
									</svg>
								</a>
								<a class="author-twitter" target="_blank" href="https://twitter.com/bengsfort">
									<svg class="icon icon-twitter-with-circle">
										<use xlink:href="#icon-twitter-with-circle" />
									</svg>
								</a>
							</div>
						</div>
					</div>			<nav id="site-navigation">
						<ul class="site-nav">
								<li >
									<a href="/" class="waves-effect">All Posts</a>
								</li>
								<li class="active">
									<a href="/articles/" class="waves-effect">Articles</a>
								</li>
								<li >
									<a href="/dev-logs/" class="waves-effect">Dev Logs</a>
								</li>
								<li >
									<a href="/pixel-art/" class="waves-effect">Pixel Art</a>
								</li>
								<li >
									<a href="/about/" class="waves-effect">About</a>
								</li>
						</ul>
					</nav>		</div>
				<div class="nav-footer">
					<span class="copyright-info"><i class="tiny material-icons">copyright</i> Matt Bengston</span>
					<span class="source-info"><a href="https://github.com/bengsfort/bengsfort.github.io" target="_blank"><i class="tiny material-icons">code</i> View on Github</a></span>
				</div>	</div>
		</header>
		<main class="main-wrapper">
			<div class="container">
				<section class="intro-text">
					<h1 class="headline">Calculating iBeacon distances with optimized averaging</h1>
						<span class="subtitle">The past few weeks I&#x27;ve been working a lot with calculating user/device location via signal strength from iBeacons, and 90% of the time it feels like playing Russian Roulette with an Imperial Blaster. Here&#x27;s how I got rid of the guess work via optimizing data averaging.</span>
				</section>				<p>It&#39;s no real secret that beacons are most certainly still an &quot;emerging technology&quot; with some growing pains. Unfortunately when you&#39;re working on a hybrid app that depends on them, you kind of have to figure out a way to make things work. In this instance, it&#39;s trying to weed-out the distance/signal strength inconsistencies so user location can be calculated correctly and accurately. </p>
<h2 id="the-problem">The problem</h2>
<p>When you&#39;re detecting your beacons via an app that&#39;s listening for them (using the <a href="https://github.com/petermetz/cordova-plugin-ibeacon">Proximity Beacon Plugin</a> for <a href="https://cordova.apache.org/">Cordova</a>/<a href="http://ionicframework.com/">Ionic</a>, for example) you receive a constant bombardment of objects representing that beacon that you can do with as you please, including an estimated distance <em>(referred to as Accuracy)</em>. Here&#39;s an example object you could expect to see back:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// Example beacon object</span>
{
    <span class="hljs-attr">proximity</span>: <span class="hljs-string">'ProximityNear'</span>,
    <span class="hljs-attr">accuracy</span>: <span class="hljs-number">3.39</span>,
    <span class="hljs-attr">uuid</span>: <span class="hljs-string">'140b70ed-cfb3-418g-8611-4dcd06d2d63d'</span>,
    <span class="hljs-attr">major</span>: <span class="hljs-number">7</span>,
    <span class="hljs-attr">minor</span>: <span class="hljs-number">5</span>,
    <span class="hljs-attr">rssi</span>: <span class="hljs-number">50</span>,
    <span class="hljs-attr">tx</span>: <span class="hljs-number">1</span>
}</code></pre>

<p>Now, when I say you get bombarded by these objects I mean it. To circumvent this and spare the users phone my team and I have a throttling service that only allows us to submit the beacon data for location calculation every 3 seconds or so, however we noticed a major issue crop up every so often which involved our distance (accuracy, line 4) being incredibly inaccurate. We&#39;re talking upwards of 4 meters off from where we knew we were standing, which when the end result gets compared to a set of boundaries to determine whether or not the device is in a specified zone is a pretty big deal.</p>
<p>After lots of research and lots of data logging, we discovered two things:</p>
<ol>
<li>On average the distance reported by the beacon is somewhat consistent, however the pool of reported distances gets polluted by plenty hilariously inaccurate distances.</li>
<li>Since we were not taking an average of our collection of distances, the distance that would get submitted for calculation was the last distance received before the timeout was finished; basically Beacon Distance Roulette. </li>
</ol>
<p>Number 2 isn&#39;t too big of an issue as it just involves storing beacon data in beacon-unique arrays then calculating the average of the stored distances for each array, which if the distances are stored as an array would be an extremely simple procedure:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// Example averaging of a beacon array</span>
<span class="hljs-keyword">var</span> averages = [];

<span class="hljs-comment">// Iterate through beacons</span>
<span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> beacons) {
  <span class="hljs-comment">// beacons[key] = [5.27, 6.07, 5.45, 5.05, 4.04, 4.37, 4.55]</span>
  averages[key] = beacons[key].reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prev, cur</span>) </span>{
    <span class="hljs-keyword">return</span> prev + cur;
  }) / arr.length; <span class="hljs-comment">// 4.97</span>
}

<span class="hljs-comment">// submit `averages` for calculation</span></code></pre>

<p>So that leaves us with tricky number 1, which would fall short when it comes to regular averaging if there were enough inaccurate distances; therefore requiring a more intricate solution. </p>
<h2 id="the-solution">The solution</h2>
<p>My first solution was to average the list twice, the first time being used to create a middle point to calculate the data pool for the second average. This however proved to be inaccurate as the distance inconsistencies grew farther apart. </p>
<p>The solution I decided to go with was to create a simple utility that would iterate through the array of numbers, tally up how many times each whole number appeared within the array, then use along with a buffer to establish boundaries that I could use to ignore unreliable data. Coupled with the throttling, this turned out to be exactly the solution we were looking for/</p>
<p>I first decided to scaffold out the utility so I could get an idea of exactly what it was it would need to do. This is generally where I start with everything that I make, as I just find it easier to go through at a high level then start to dive in deeper where necessary.</p>
<pre><code><span class="hljs-comment">/**
 * Optimized Average calculation
 * Takes an array of numbers, then throws away unreliable numbers
 * to get a more precise average.
 *
 * @param {number[]} Numbers - Array of numbers to optimize.
 * @returns {number} - The optimized average, rounded to the nearest hundredth.
 */</span> 
<span class="hljs-keyword">var</span> optimizedAverage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">optimizeDistanceAverage</span>(<span class="hljs-params"> Numbers </span>) </span>{
  <span class="hljs-comment">// Tally up the amount of times a whole number occurs in the array</span>
  <span class="hljs-keyword">var</span> countNums;

  <span class="hljs-comment">// determine the most probable distance from the tally (the number that appears the most)</span>
  <span class="hljs-keyword">var</span> mostReliable;

  <span class="hljs-comment">/** 
   * Get the average of the provided numbers that are:
   *  1. Less than double the most reliable number,
   *  2. More than half the most reliable number,
   *  then round it to the nearest hundredth.
   */</span>
   <span class="hljs-keyword">var</span> average;
   <span class="hljs-keyword">return</span> average;
};

<span class="hljs-comment">// Expose Utility to whatever needs it</span>
<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> === <span class="hljs-string">"object"</span> &amp;&amp; <span class="hljs-built_in">module</span>.exports ) <span class="hljs-built_in">module</span>.exports = optimizedAverage;
<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">"undefined"</span> ) <span class="hljs-built_in">window</span>.optimizedAverage = optimizedAverage;</code></pre>

<p>Let&#39;s start by writing some helpers that will come in handy for the rest, like an averaging function as well as a rounding function.</p>
<pre><code>. . .
<span class="hljs-keyword">var</span> optimizedAverage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">optimizeDistanceAverage</span><span class="hljs-params">( Numbers )</span> </span>{
  <span class="hljs-comment">/**
   * Get the average from an array of numbers
   * <span class="hljs-doctag">@param</span> {number[]} arr - Array of numbers to average
   * <span class="hljs-doctag">@returns</span> {number} - The average of the numbers.
   */</span>
  <span class="hljs-keyword">var</span> getAverage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAverage</span><span class="hljs-params">( arr )</span> </span>{
    <span class="hljs-keyword">return</span> arr.reduce( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduceGetAverage</span><span class="hljs-params">( prev, cur )</span> </span>{
      <span class="hljs-keyword">return</span> prev + cur;
    }) / arr.length;
  };

  <span class="hljs-comment">/**
   * Round a number to the nearest hundredth
   * <span class="hljs-doctag">@param</span> {number} num - the number to round
   * <span class="hljs-doctag">@returns</span> {number} - the rounded result
   */</span>
  <span class="hljs-keyword">var</span> roundResult = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">roundResult</span><span class="hljs-params">( num )</span> </span>{
    <span class="hljs-keyword">return</span> ( Math.round( num * <span class="hljs-number">100</span> ) / <span class="hljs-number">100</span> ).toFixed( <span class="hljs-number">2</span> );
  };
  . . .
};
. . .</code></pre>

<p>The averaging function (<code>getAverage()</code>, <em>lines 7 - 11</em>) is essentially the same as the block shown in the last section that averaged the array, so nothing new there. The rounding function (<code>roundResult()</code>, <em>lines 18 - 20</em>) isn&#39;t anything too special either, they&#39;re just some math calculations that would be extremely annoying to write more than once.</p>
<p>From there we can start getting into the real meat-and-potatoes of the utility, namely the function that iterates through the distance array and tallies up how popular each whole number is. Since it&#39;s JavaScript and this involves iterating through an array, there are obviously 8 million and four ways to write it however on this occasion I&#39;m feeling the humble <code>for(;;) {}</code> loop, particularly because I&#39;ve got to be able to declare keys to properly track each number.</p>
<pre><code><span class="hljs-comment">/**
 * Tallies up the amount of times a whole number occurs in the array.
 * @param {number[]} numbers - Array of numbers to iterate over.
 * @returns {object} - Returns the completed tally object.
 */</span>
<span class="hljs-keyword">var</span> countNums = function countNums( numbers ) {
  <span class="hljs-keyword">var</span> <span class="hljs-keyword">count</span> = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = 0; i &lt; numbers.length; ++i) {
    <span class="hljs-comment">// Cache the whole number</span>
    <span class="hljs-keyword">var</span> floored = Math.<span class="hljs-built_in">floor</span>( numbers[i] );
    <span class="hljs-comment">// Check to see if we've already stored the number</span>
    <span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">count</span>.hasOwnProperty( floored ) ) {
      <span class="hljs-keyword">count</span>[floored] = 1; <span class="hljs-comment">// Start off the numbers tally</span>
    } <span class="hljs-keyword">else</span> {
      ++<span class="hljs-keyword">count</span>[floored]; <span class="hljs-comment">// Add to the tally</span>
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span>;
}( Numbers ); <span class="hljs-comment">// Self-invoke the function with the `Numbers` array</span></code></pre>

<p>As for loops go it&#39;s a pretty basic one, but I&#39;ll walk you through what we&#39;re doing just in case:</p>
<ol>
<li>Creating an empty array to hold our number tallies. <em>(line 6)</em></li>
<li>Iterating through the passed in array, storing the active whole number as we go. <em>(lines 8, 10)</em></li>
<li>Checking to see if the number already has a tally, if not we start it off at 1 and if so we increment it by 1. <em>(lines 12 - 16)</em></li>
<li>Returning the array containing our tallies, then self-invoking the function with the array of distances passed into the utility. <em>(lines 19, 20)</em></li>
</ol>
<p>From there we&#39;re on the home stretch, as now we have an array telling us how many times each distance present in the array appears, so we can easily determine the most probable distance and use that to create a buffer zone of distances we&#39;ll still accept for our final average.</p>
<pre><code><span class="hljs-comment">// Determine the most reliable number (the number that appears most)</span>
<span class="hljs-keyword">var</span> mostReliable = countNums.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduceMostReliable</span><span class="hljs-params">(prev, cur, i, arr)</span> </span>{
  <span class="hljs-keyword">return</span> arr[prev] &gt; cur ? prev : i;
}, <span class="hljs-number">0</span>);</code></pre>

<p>Since we&#39;re saving our array containing our tally <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">reduce</a> can come to the rescue and <em>reduce</em> our array down to a single, probable distance. This could be done a little bit more readable, but I&#39;ll break down the logic so it&#39;s a little bit easier to understand what&#39;s going on. </p>
<p>The indexes of the array are the whole numbers that we got from our distances, so those are always available to us via <code>i</code>; since reduce provides the last returned value as <code>prev</code>, we can essentially persist the most probably whole number through <code>prev</code>, and still be able to access the amount of times it appeared by pointing the array to that index (<code>arr[prev]</code>). Therefore:</p>
<pre><code>if the current probable number (prev) appeared more times (arr[prev]) than the current value (cur)
   return the current probable number;
   otherwise return the current values index as the new probable number (i)
</code></pre><p>A little bit confusing, I know, but the second it clicks it makes all the sense in the world. As a bonus, it also means we&#39;re one code block away from being done! Lastly we have to get the rounded average of our reliable distances, which are dictated by whether or not they are:</p>
<ol>
<li>Less than double the most probable distance</li>
<li>More than half of the most probable distance</li>
</ol>
<p>There are a couple different ways to write this, so I&#39;ll start with the easy to read version then show the more compact version.</p>
<pre><code><span class="hljs-comment">/** 
 * Create a new array with the provided numbers that are:
 *  1. Less than double the most probable distance,
 *  2. More than half the most probable distance,
 */</span>
<span class="hljs-keyword">var</span> reliableList = Numbers.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> num </span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.ceil( num ) &gt; ( mostReliable / <span class="hljs-number">2</span> ) <span class="hljs-comment">// ceil of the number is greater than half </span>
      &amp;&amp; <span class="hljs-built_in">Math</span>.floor( num ) &lt; ( mostReliable * <span class="hljs-number">2</span> ); <span class="hljs-comment">// floor of the number is less than double</span>
});

<span class="hljs-comment">// Get the average of our new array</span>
<span class="hljs-keyword">var</span> reliableAverage = getAverage( reliableList );
<span class="hljs-comment">// Return the rounded average</span>
<span class="hljs-keyword">return</span> roundResult( reliableAverage );</code></pre>

<p>Here all we&#39;re doing is filtering through our original list and picking out any numbers that are over or under a certain threshold, that way we can keep our data pool small and accurate and get a better average. I&#39;ve got it set at double and half, as I noticed that was a good buffer when reviewing the range of inconsistency in our data logs. </p>
<p>By setting it at double and half we provide a larger buffer for the higher distances (which have a larger range of inconsistency), and far less wiggle room when we&#39;re closer to the beacon (when the distance will have less inconsistencies); making smaller distances more accurate and farther distances easier to estimate.</p>
<p>Like I said though, this final block can be written a little bit more concise as well:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">/** 
 * Create a new array with the provided numbers that are:
 *  1. Less than double the most probable distance,
 *  2. More than half the most probable distance,
 */</span>
<span class="hljs-keyword">return</span> roundResult( getAverage( Numbers.filter( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> num </span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.ceil( num ) &gt; ( mostReliable / <span class="hljs-number">2</span> ) &amp;&amp; <span class="hljs-built_in">Math</span>.floor( num ) &lt; ( mostReliable * <span class="hljs-number">2</span> );
}) ) );</code></pre>

<p>Yummy, what was previously 8 lines is now 3! This is another benefit of us adding our helpers in earlier, instead of having to toss all of those calculations inline we can just call them in our return on the fly after calculating our new reliableList.</p>
<p>After all is said and done piping our distances through this utility should allow us to get far more accurate distance calculations thanks to ignoring unreliable data. Here&#39;s the results from some test runs I ran so you can see what I mean:</p>
<pre><code>Numbers provided: [1.97, 1.74, 1.44, 1.5, 1.47, 1.41, 1.42, 1.22, 1.17, 1.2, 2.15]
Pre-optimized average: 1.52
Numbers discarded: 1
Optimized average: 1.45

Numbers provided: [5.27, 2.25, 2.45, 1.87, 1.89, 2.11, 1.97, 2.06, 1.93, 2.22, 2.22]
Pre-optimized average: 2.39
Numbers discarded: 1
Optimized average: 2.10

Numbers provided: [14.78, 2.25, 2.45, 1.87, 1.89, 2.11, 9.33, 1.97, 2.06, 1.93, 2.22, 2.22, 11.17]
Pre-optimized average: 4.33
Numbers discarded: 3
Optimized average: 2.22
</code></pre><p>You can view the full file <a href="https://github.com/aesinv/optimized-averages/blob/master/optimizedAverages.js">on GitHub</a>, with full comments and ready to roll. You can also play around with it on <a href="https://tonicdev.com/npm/optimized-averages">Tonic</a>.</p>
<p>Cheers!</p>

			</div>
		</main>

		<svg style="position: absolute; width: 0; height: 0; overflow: hidden;" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		  <defs>
		    <symbol id="icon-github-with-circle" viewBox="0 0 20 20">
		      <title>github-with-circle</title>
		      <path class="path1" d="M10.015 9.949c0 0-0.010 0-0.015 0h-0.015c-1.191 0-2.24-0.303-2.861 0.268-0.371 0.342-0.527 0.754-0.527 1.197 0 1.852 1.483 2.080 3.389 2.080h0.029c1.905 0 3.389-0.229 3.389-2.080 0-0.443-0.156-0.856-0.527-1.197-0.622-0.571-1.671-0.268-2.862-0.268zM8.393 12.48c-0.363 0-0.656-0.408-0.656-0.91s0.293-0.908 0.656-0.908c0.363 0 0.657 0.406 0.657 0.908s-0.293 0.91-0.657 0.91zM11.606 12.48c-0.363 0-0.657-0.408-0.657-0.91s0.294-0.908 0.657-0.908c0.362 0 0.656 0.406 0.656 0.908s-0.293 0.91-0.656 0.91zM10 0.4c-5.302 0-9.6 4.298-9.6 9.6s4.298 9.6 9.6 9.6 9.6-4.298 9.6-9.6-4.298-9.6-9.6-9.6zM10.876 13.939c-0.172 0-0.514 0-0.876 0.002-0.362-0.002-0.704-0.002-0.876-0.002-0.76 0-3.772-0.059-3.772-3.689 0-0.834 0.286-1.445 0.755-1.955-0.074-0.184-0.078-1.232 0.32-2.236 0 0 0.916 0.1 2.301 1.051 0.289-0.081 0.781-0.122 1.272-0.122s0.982 0.041 1.273 0.121c1.385-0.951 2.301-1.051 2.301-1.051 0.398 1.004 0.395 2.053 0.32 2.236 0.469 0.51 0.755 1.121 0.755 1.955-0.001 3.632-3.013 3.69-3.773 3.69z"></path>
		    </symbol>
		    <symbol id="icon-twitter-with-circle" viewBox="0 0 20 20">
		      <title>twitter-with-circle</title>
		      <path class="path1" d="M10 0.4c-5.302 0-9.6 4.298-9.6 9.6s4.298 9.6 9.6 9.6 9.6-4.298 9.6-9.6-4.298-9.6-9.6-9.6zM13.905 8.264c0.004 0.082 0.005 0.164 0.005 0.244 0 2.5-1.901 5.381-5.379 5.381-1.068 0-2.062-0.312-2.898-0.85 0.147 0.018 0.298 0.025 0.451 0.025 0.886 0 1.701-0.301 2.348-0.809-0.827-0.016-1.525-0.562-1.766-1.312 0.115 0.021 0.233 0.033 0.355 0.033 0.172 0 0.34-0.023 0.498-0.066-0.865-0.174-1.517-0.938-1.517-1.854v-0.023c0.255 0.141 0.547 0.227 0.857 0.237-0.508-0.34-0.841-0.918-0.841-1.575 0-0.346 0.093-0.672 0.256-0.951 0.933 1.144 2.325 1.896 3.897 1.977-0.033-0.139-0.049-0.283-0.049-0.432 0-1.043 0.846-1.891 1.891-1.891 0.543 0 1.035 0.23 1.38 0.598 0.431-0.086 0.835-0.242 1.2-0.459-0.141 0.441-0.44 0.812-0.831 1.047 0.383-0.047 0.747-0.148 1.086-0.299-0.253 0.379-0.574 0.713-0.943 0.979z"></path>
		    </symbol>
		  </defs>
		</svg>
		<script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
		<script type="text/javascript" src="/js/bin/materialize.min.js"></script>
		<script type="text/javascript">
			var trigger = $('.nav-menu-trigger'),
				target = $(trigger.data('target'));
			
			trigger.on('click', function() {
				trigger.toggleClass('active');
				target.toggleClass('in');
			});
		</script>		<script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
		
		  ga('create', 'UA-66600710-1', 'auto');
		  ga('send', 'pageview');
		</script>
		
		<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
		<script>
		  (adsbygoogle = window.adsbygoogle || []).push({
		    google_ad_client: "ca-pub-7029788304714937",
		    enable_page_level_ads: true
		  });
		</script>	</body>
</html>